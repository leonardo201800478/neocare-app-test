import { ConcurrentLockType } from './types';
import { enhanceQueryResult } from './utils';
import { DBListenerManagerInternal } from './DBListenerManager';
var TransactionFinalizer = /*#__PURE__*/function (TransactionFinalizer) {
  TransactionFinalizer["COMMIT"] = "commit";
  TransactionFinalizer["ROLLBACK"] = "rollback";
  return TransactionFinalizer;
}(TransactionFinalizer || {});
const DEFAULT_READ_CONNECTIONS = 4;

// A incrementing integer ID for tracking lock requests
let requestIdCounter = 1;
const getRequestId = () => {
  requestIdCounter++;
  return `${requestIdCounter}`;
};
const LockCallbacks = {};
let proxy;

/**
 * Closes the context in JS and C++
 */
function closeContextLock(dbName, id) {
  delete LockCallbacks[id];

  // This is configured by the setupOpen function
  proxy.releaseLock(dbName, id);
}

/**
 * JS callback to trigger queued callbacks when a lock context is available.
 * Declared on the global scope so that C++ can call it.
 * @param lockId
 * @returns
 */
global.onLockContextIsAvailable = async (dbName, lockId) => {
  // Don't hold C++ bridge side up waiting to complete
  setImmediate(async () => {
    try {
      const record = LockCallbacks[lockId];
      if (record !== null && record !== void 0 && record.timeout) {
        clearTimeout(record.timeout);
      }
      await (record === null || record === void 0 ? void 0 : record.callback({
        // @ts-expect-error This is not part of the public interface, but is used internally
        _contextId: lockId,
        execute: async (sql, args) => {
          const result = await proxy.executeInContext(dbName, lockId, sql, args);
          enhanceQueryResult(result);
          return result;
        }
      }));
    } catch (ex) {
      console.error(ex);
    }
  });
};

/**
 * Generates the entry point for opening concurrent connections
 * @param proxy
 * @returns
 */
export function setupOpen(QuickSQLite) {
  // Allow the Global callbacks to close lock contexts
  proxy = QuickSQLite;
  return {
    /**
     * Opens a SQLite DB connection.
     * By default opens DB in WAL mode with 4 Read connections and a single
     * write connection
     */
    open: (dbName, options = {}) => {
      // Opens the connection
      QuickSQLite.open(dbName, {
        ...options,
        numReadConnections: (options === null || options === void 0 ? void 0 : options.numReadConnections) ?? DEFAULT_READ_CONNECTIONS
      });
      const listenerManager = new DBListenerManagerInternal({
        dbName
      });

      /**
       * Wraps lock requests and their callbacks in order to resolve the lock
       * request with the callback result once triggered from the connection pool.
       */
      const requestLock = (type, callback, options, hooks) => {
        const id = getRequestId();
        // Wrap the callback in a promise that will resolve to the callback result
        return new Promise((resolve, reject) => {
          // Add callback to the queue for timing
          const record = LockCallbacks[id] = {
            callback: async context => {
              try {
                var _hooks$lockAcquired;
                await (hooks === null || hooks === void 0 || (_hooks$lockAcquired = hooks.lockAcquired) === null || _hooks$lockAcquired === void 0 ? void 0 : _hooks$lockAcquired.call(hooks));
                const res = await callback(context);
                closeContextLock(dbName, id);
                resolve(res);
              } catch (ex) {
                closeContextLock(dbName, id);
                reject(ex);
              } finally {
                var _hooks$lockReleased;
                hooks === null || hooks === void 0 || (_hooks$lockReleased = hooks.lockReleased) === null || _hooks$lockReleased === void 0 || _hooks$lockReleased.call(hooks);
              }
            }
          };
          try {
            QuickSQLite.requestLock(dbName, id, type);
            const timeout = options === null || options === void 0 ? void 0 : options.timeoutMs;
            if (timeout) {
              record.timeout = setTimeout(() => {
                // The callback won't be executed
                delete LockCallbacks[id];
                reject(new Error(`Lock request timed out after ${timeout}ms`));
              }, timeout);
            }
          } catch (ex) {
            // Remove callback from the queue
            delete LockCallbacks[id];
            reject(ex);
          }
        });
      };
      const readLock = (callback, options) => requestLock(ConcurrentLockType.READ, callback, options);
      const writeLock = (callback, options) => requestLock(ConcurrentLockType.WRITE, callback, options, {
        lockReleased: async () => {
          // flush updates once a write lock has been released
          listenerManager.flushUpdates();
        }
      });
      const wrapTransaction = async (context, callback, defaultFinalizer = TransactionFinalizer.COMMIT) => {
        await context.execute('BEGIN TRANSACTION');
        let finalized = false;
        const finalizedStatement = action => () => {
          if (finalized) {
            return;
          }
          finalized = true;
          return action();
        };
        const commit = finalizedStatement(async () => context.execute('COMMIT'));
        const rollback = finalizedStatement(async () => context.execute('ROLLBACK'));
        const wrapExecute = method => async (sql, params) => {
          if (finalized) {
            throw new Error(`Cannot execute in transaction after it has been finalized with commit/rollback.`);
          }
          return method(sql, params);
        };
        try {
          const res = await callback({
            ...context,
            commit,
            rollback,
            execute: wrapExecute(context.execute)
          });
          switch (defaultFinalizer) {
            case TransactionFinalizer.COMMIT:
              await commit();
              break;
            case TransactionFinalizer.ROLLBACK:
              await rollback();
              break;
          }
          return res;
        } catch (ex) {
          try {
            await rollback();
          } catch (ex2) {
            // In rare cases, a rollback may fail.
            // Safe to ignore.
          }
          throw ex;
        }
      };

      // Return the concurrent connection object
      return {
        close: () => QuickSQLite.close(dbName),
        execute: (sql, args) => writeLock(context => context.execute(sql, args)),
        readLock,
        readTransaction: async (callback, options) => readLock(context => wrapTransaction(context, callback)),
        writeLock,
        writeTransaction: async (callback, options) => writeLock(context => wrapTransaction(context, callback, TransactionFinalizer.COMMIT), options),
        delete: () => QuickSQLite.delete(dbName, options === null || options === void 0 ? void 0 : options.location),
        executeBatch: commands => writeLock(context => QuickSQLite.executeBatch(dbName, commands, context._contextId)),
        attach: (dbNameToAttach, alias, location) => QuickSQLite.attach(dbName, dbNameToAttach, alias, location),
        detach: alias => QuickSQLite.detach(dbName, alias),
        loadFile: location => writeLock(context => QuickSQLite.loadFile(dbName, location, context._contextId)),
        listenerManager,
        registerUpdateHook: callback => listenerManager.registerListener({
          rawTableChange: callback
        }),
        registerTablesChangedHook: callback => listenerManager.registerListener({
          tablesUpdated: callback
        })
      };
    }
  };
}
//# sourceMappingURL=setup-open.js.map