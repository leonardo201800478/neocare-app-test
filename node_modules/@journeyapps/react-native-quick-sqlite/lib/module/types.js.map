{"version":3,"names":["RowUpdateType","TransactionEvent","ConcurrentLockType"],"sources":["types.ts"],"sourcesContent":["import { DBListenerManager } from './DBListenerManager';\n\n/**\n * Object returned by SQL Query executions {\n *  insertId: Represent the auto-generated row id if applicable\n *  rowsAffected: Number of affected rows if result of a update query\n *  message: if status === 1, here you will find error description\n *  rows: if status is undefined or 0 this object will contain the query results\n * }\n *\n * @interface QueryResult\n */\nexport type QueryResult = {\n  insertId?: number;\n  rowsAffected: number;\n  rows?: {\n    /** Raw array with all dataset */\n    _array: any[];\n    /** The lengh of the dataset */\n    length: number;\n    /** A convenience function to acess the index based the row object\n     * @param idx the row index\n     * @returns the row structure identified by column names\n     */\n    item: (idx: number) => any;\n  };\n  /**\n   * Query metadata, avaliable only for select query results\n   */\n  metadata?: ColumnMetadata[];\n};\n\n/**\n * Column metadata\n * Describes some information about columns fetched by the query\n */\nexport type ColumnMetadata = {\n  /** The name used for this column for this resultset */\n  columnName: string;\n  /** The declared column type for this column, when fetched directly from a table or a View resulting from a table column. \"UNKNOWN\" for dynamic values, like function returned ones. */\n  columnDeclaredType: string;\n  /**\n   * The index for this column for this resultset*/\n  columnIndex: number;\n};\n\n/**\n * Allows the execution of bulk of sql commands\n * inside a transaction\n * If a single query must be executed many times with different arguments, its preferred\n * to declare it a single time, and use an array of array parameters.\n */\nexport type SQLBatchTuple = [string] | [string, Array<any> | Array<Array<any>>];\n\n/**\n * status: 0 or undefined for correct execution, 1 for error\n * message: if status === 1, here you will find error description\n * rowsAffected: Number of affected rows if status == 0\n */\nexport type BatchQueryResult = {\n  rowsAffected?: number;\n};\n\n/**\n * Result of loading a file and executing every line as a SQL command\n * Similar to BatchQueryResult\n */\nexport interface FileLoadResult extends BatchQueryResult {\n  commands?: number;\n}\n\nexport enum RowUpdateType {\n  SQLITE_INSERT = 18,\n  SQLITE_DELETE = 9,\n  SQLITE_UPDATE = 23\n}\n\nexport interface TableUpdateOperation {\n  opType: RowUpdateType;\n  rowId: number;\n}\nexport interface UpdateNotification extends TableUpdateOperation {\n  table: string;\n}\n\nexport interface BatchedUpdateNotification {\n  rawUpdates: UpdateNotification[];\n  tables: string[];\n  groupedUpdates: Record<string, TableUpdateOperation[]>;\n}\n\nexport type UpdateCallback = (update: UpdateNotification) => void;\nexport type BatchedUpdateCallback = (update: BatchedUpdateNotification) => void;\n\nexport enum TransactionEvent {\n  COMMIT,\n  ROLLBACK\n}\n\nexport type TransactionCallback = (eventType: TransactionEvent) => void;\n\nexport type ContextLockID = string;\n\nexport enum ConcurrentLockType {\n  READ,\n  WRITE\n}\n\nexport type OpenOptions = {\n  location?: string;\n  /**\n   * The number of concurrent read connections to use.\n   * Setting this value to zero will only open a single write connection.\n   * Setting this value > 0 will open the DB in WAL mode with [numReadConnections]\n   * read connections and a single write connection. This allows for concurrent\n   * read operations during a write operation.\n   */\n  numReadConnections?: number;\n};\n\nexport type Open = (dbName: string, options?: OpenOptions) => QuickSQLiteConnection;\n\nexport interface ISQLite {\n  open: Open;\n  close: (dbName: string) => void;\n  delete: (dbName: string, location?: string) => void;\n\n  requestLock: (dbName: string, id: ContextLockID, type: ConcurrentLockType) => QueryResult;\n  releaseLock(dbName: string, id: ContextLockID): void;\n  executeInContext: (dbName: string, id: ContextLockID, query: string, params: any[]) => Promise<QueryResult>;\n\n  attach: (mainDbName: string, dbNameToAttach: string, alias: string, location?: string) => void;\n  detach: (mainDbName: string, alias: string) => void;\n\n  executeBatch: (dbName: string, commands: SQLBatchTuple[], id: ContextLockID) => Promise<BatchQueryResult>;\n  loadFile: (dbName: string, location: string, id: ContextLockID) => Promise<FileLoadResult>;\n}\n\nexport interface LockOptions {\n  timeoutMs?: number;\n}\n\nexport interface LockContext {\n  execute: (sql: string, args?: any[]) => Promise<QueryResult>;\n}\n\nexport interface TransactionContext extends LockContext {\n  commit: () => Promise<QueryResult>;\n  rollback: () => Promise<QueryResult>;\n}\n\nexport type QuickSQLiteConnection = {\n  close: () => void;\n  execute: (sql: string, args?: any[]) => Promise<QueryResult>;\n  readLock: <T>(callback: (context: LockContext) => Promise<T>, options?: LockOptions) => Promise<T>;\n  readTransaction: <T>(callback: (context: TransactionContext) => Promise<T>, options?: LockOptions) => Promise<T>;\n  writeLock: <T>(callback: (context: LockContext) => Promise<T>, options?: LockOptions) => Promise<T>;\n  writeTransaction: <T>(callback: (context: TransactionContext) => Promise<T>, options?: LockOptions) => Promise<T>;\n  delete: () => void;\n  /**\n   * The attach method should only be called if there are no active locks/transactions.\n   */\n  attach: (dbNameToAttach: string, alias: string, location?: string) => void;\n  /**\n   * The detach method should only be called if there are no active locks/transactions.\n   */\n  detach: (alias: string) => void;\n  executeBatch: (commands: SQLBatchTuple[]) => Promise<BatchQueryResult>;\n  loadFile: (location: string) => Promise<FileLoadResult>;\n  /**\n   * Register a callback which will be fired for each ROWID table change event.\n   * Table changes are reported immediately.\n   * Changes might not yet be committed if using a transaction.\n   *  - Listen to transaction events in listenerManager if extra logic is required\n   * For most use cases use `registerTablesChangedHook` instead.\n   * @returns a function which will deregister the callback\n   */\n  registerUpdateHook(callback: UpdateCallback): () => void;\n  /**\n   * Register a callback which will be fired whenever a update to a ROWID table\n   * has been committed.\n   * Changes inside write locks will be buffered until the lock is released or\n   * if a transaction inside the lock has been committed.\n   * Reverting a transaction inside a write lock will not fire table updates.\n   * @returns a function which will deregister the callback\n   */\n  registerTablesChangedHook(callback: BatchedUpdateCallback): () => void;\n  listenerManager: DBListenerManager;\n};\n"],"mappings":"AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAqBA;AACA;AACA;AACA;;AAWA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAKA;AACA;AACA;AACA;;AAKA,WAAYA,aAAa,0BAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAA,OAAbA,aAAa;AAAA;AAuBzB,WAAYC,gBAAgB,0BAAhBA,gBAAgB;EAAhBA,gBAAgB,CAAhBA,gBAAgB;EAAhBA,gBAAgB,CAAhBA,gBAAgB;EAAA,OAAhBA,gBAAgB;AAAA;AAS5B,WAAYC,kBAAkB,0BAAlBA,kBAAkB;EAAlBA,kBAAkB,CAAlBA,kBAAkB;EAAlBA,kBAAkB,CAAlBA,kBAAkB;EAAA,OAAlBA,kBAAkB;AAAA","ignoreList":[]}